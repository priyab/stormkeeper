// Generated by CoffeeScript 1.7.1
(function() {
  var StormAgent, StormKeeper, instance,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  StormAgent = require('stormagent');

  StormKeeper = (function(_super) {
    var cleanupInterval, ruleschema, tokenMaxDuration, tokenschema, uuid, validate;

    __extends(StormKeeper, _super);

    validate = require('json-schema').validate;

    uuid = require('node-uuid');

    cleanupInterval = 5 * 1000;

    tokenMaxDuration = 240 * 1000;

    tokenschema = {
      name: "tokens",
      type: "object",
      additionalProperties: false,
      properties: {
        id: {
          type: "string",
          "required": false
        },
        name: {
          type: "string",
          "required": false
        },
        domainId: {
          type: "string",
          "required": true
        },
        identityId: {
          type: "string",
          "required": true
        },
        rulesId: {
          type: "string",
          "required": true
        },
        expiry: {
          type: "number",
          "required": true
        },
        lastModified: {
          type: "string",
          "required": false
        },
        userData: {
          type: "array",
          items: {
            type: "object",
            required: false,
            additionalProperties: true,
            properties: {
              accountId: {
                "type": "string",
                "required": false
              },
              userEmail: {
                "type": "string",
                "required": false
              }
            }
          }
        }
      }
    };

    ruleschema = {
      name: "rules",
      type: "object",
      additionalProperties: false,
      properties: {
        id: {
          "type": "string",
          "required": false
        },
        name: {
          "type": "string",
          "required": false
        },
        rules: {
          "type": "array",
          "required": true
        },
        role: {
          "type": "string",
          "required": true
        }
      }
    };

    function StormKeeper() {
      StormKeeper.__super__.constructor.apply(this, arguments);
      this["import"](module);
      this.log('stormkeeper constructor called');
      this.db = {};
      this.newdb("" + this.config.datadir + "/tokens.db", (function(_this) {
        return function(err, db) {
          if (err) {
            return;
          }
          _this.db.tokensdb = db;
          _this.log('loaded tokens.db');
          return db.forEach(function(key, val) {
            if (val) {
              return this.log('Tokens found ' + key);
            }
          });
        };
      })(this));
      this.newdb("" + this.config.datadir + "/rules.db", (function(_this) {
        return function(err, db) {
          if (err) {
            return;
          }
          _this.db.rulesdb = db;
          _this.log('loaded rules.db');
          return db.forEach(function(key, val) {
            if (val) {
              return this.log('Rules found ' + key);
            }
          });
        };
      })(this));
      setInterval(((function(_this) {
        return function() {
          return _this.updateTokenExpiry(cleanupInterval);
        };
      })(this)), cleanupInterval);
    }

    StormKeeper.prototype["new"] = function() {
      var id;
      id = uuid.v4();
      return id;
    };

    StormKeeper.prototype.newEntry = function(entry, id) {
      if (id) {
        entry.id = id;
      } else {
        entry.id = this["new"]();
      }
      return entry;
    };

    StormKeeper.prototype.getRelativeDB = function(type) {
      var keeperDb;
      keeperDb = '';
      switch (type) {
        case "TOKENS":
          keeperDb = this.db.tokensdb;
          break;
        case "RULES":
          keeperDb = this.db.rulesdb;
      }
      return keeperDb;
    };

    StormKeeper.prototype.checkentryschema = function(type, entry, callback) {
      var entryschema, error, result;
      if (type === 'TOKENS') {
        entryschema = tokenschema;
      }
      if (type === 'RULES') {
        entryschema = ruleschema;
      }
      if (entryschema != null) {
        this.log('performing entryschema validation on a new entry posting');
        if (!entry) {
          return new Error("Entry data is missing");
        }
        result = validate(entry, entryschema);
        error = new Error("Invalid entry posting!");
        if (!result.valid) {
          throw error;
        }
        return callback(result);
      } else {
        return callback(new Error("No valid schema to compare:"));
      }
    };

    StormKeeper.prototype.getEntriesById = function(type, id, callback) {
      var entry, keeperdb;
      this.log("looking up entry ID: " + id);
      keeperdb = this.getRelativeDB(type);
      entry = keeperdb.get(id);
      if (entry != null) {
        return this.checkentryschema(type, entry, (function(_this) {
          return function(result) {
            _this.log(result);
            if (!result.valid) {
              return callback(new Error("Invalid entry retrieved: " + result.errors));
            }
            return callback(entry);
          };
        })(this));
      } else {
        return callback(new Error("Entry not found: " + id));
      }
    };

    StormKeeper.prototype.getTokens = function() {
      var res;
      res = {
        tokens: []
      };
      this.db.tokensdb.forEach(function(key, val) {
        if (val) {
          return res.tokens.push(val);
        }
      });
      return res;
    };

    StormKeeper.prototype.getRules = function(usertype, callback) {
      var entry, rules;
      rules = {};
      this.db.rulesdb.forEach(function(key, rule) {
        var rulekey, rulevalue;
        if (usertype != null) {
          for (rulekey in rule) {
            rulevalue = rule[rulekey];
            if (rulevalue === usertype) {
              return callback([rule]);
            }
          }
        } else {
          if (__indexOf.call(rules, key) < 0) {
            return rules[key] = rule;
          }
        }
      });
      return callback((function() {
        var _results;
        _results = [];
        for (entry in rules) {
          _results.push(entry);
        }
        return _results;
      })());
    };

    StormKeeper.prototype.add = function(type, entry, callback) {
      if ((type != null) && (entry != null) && entry.id) {
        return this.checkentryschema(type, entry, (function(_this) {
          return function(error) {
            var keeperdb;
            _this.log("entry:", entry);
            if (!(error instanceof Error)) {
              keeperdb = _this.getRelativeDB(type);
              _this.log("entry.id = " + entry.id);
              return keeperdb.set(entry.id, entry, function() {
                return callback(entry);
              });
            } else {
              _this.log('entry check: ' + error);
              return callback(new Error("" + entry.id + " entry not added!"));
            }
          };
        })(this));
      } else {
        return callback(new Error("Invalid entry!!"));
      }
    };

    StormKeeper.prototype.update = function(type, entry, callback) {
      if ((type != null) && (entry != null) && entry.id) {
        return this.add(type, entry, (function(_this) {
          return function(res) {
            if (callback != null) {
              return callback(res);
            }
          };
        })(this));
      } else {
        if (callback != null) {
          return callback(new Error("Could not find ID! " + id));
        }
      }
    };

    StormKeeper.prototype.remove = function(type, entry, callback) {
      var keeperdb;
      this.log('StormKeeper in DEL entry');
      keeperdb = this.getRelativeDB(type);
      if (entry != null) {
        return keeperdb.rm(entry.id, (function(_this) {
          return function() {
            _this.log("removed entry ID: " + entry.id);
            return callback({
              result: 200
            });
          };
        })(this));
      }
    };

    StormKeeper.prototype.DecrementExpiryInToken = function(token, tokenTick) {
      var tokenKey, tokenValue, _results;
      this.log('Decrement Expiry In Token by ' + tokenTick + 'ms');
      _results = [];
      for (tokenKey in token) {
        tokenValue = token[tokenKey];
        if (tokenKey === 'expiry') {
          token[tokenKey] = token[tokenKey] - tokenTick;
          this.log("Current Expiry value is " + token[tokenKey] + "ms");
          if (token[tokenKey] < 1) {
            this.db.tokensdb.rm(token.id, (function(_this) {
              return function() {};
            })(this));
            _results.push(this.log("removed token ID: " + token.id));
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    StormKeeper.prototype.resetTokenExpiry = function(token) {
      var err, tokenEntry, tokenKey, tokenValue, _results;
      try {
        this.log("resetTokenExpiry for " + token.id);
        tokenEntry = this.db.tokensdb.get(token.id);
        if (tokenEntry) {
          _results = [];
          for (tokenKey in tokenEntry) {
            tokenValue = tokenEntry[tokenKey];
            if (tokenKey === 'expiry') {
              tokenEntry[tokenKey] = tokenMaxDuration;
              _results.push(this.log(tokenEntry));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        }
      } catch (_error) {
        err = _error;
        return this.log(err);
      }
    };

    StormKeeper.prototype.updateTokenExpiry = function(tokenTick) {
      var err, res;
      try {
        this.db.tokensdb.forEach((function(_this) {
          return function(key, entry) {
            if (entry) {
              return _this.DecrementExpiryInToken(entry, tokenTick);
            }
          };
        })(this));
        return res = this.getTokens();
      } catch (_error) {
        err = _error;
        return this.log(err);
      }
    };

    return StormKeeper;

  })(StormAgent);

  instance = null;

  module.exports = function(args) {
    if (instance == null) {
      instance = new StormKeeper(args);
    }
    return instance;
  };

}).call(this);
